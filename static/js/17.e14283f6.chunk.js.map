{"version":3,"sources":["../articles/_posts/做一个基于create-react-app的脚手架.md"],"names":["module","exports","title","date","tags","header_img","key","content"],"mappings":"4EAAAA,EAAAC,QAAA,CAAkBC,MAAA,yEAAAC,KAAA,sBAAAC,KAAA,GAAAC,WAAA,GAAAC,IAAA,4EAAAC,QAAA","file":"static/js/17.e14283f6.chunk.js","sourcesContent":["module.exports = {\"title\":\"做一个基于create-react-app的脚手架\",\"date\":\"2019-05-22 11:37:57\",\"tags\":\"\",\"header_img\":\"\",\"key\":\"做一个基于create-react-app的脚手架.md\",\"content\":\"\\n\\n# 前言\\n\\n`create-react-app`作为facebook官方的react脚手架是相当好用的。主要设计原理是将配置好的如`Webpack，Babel，ESLint`，合并到`react-scripts`这npm包中，用户就可以开箱即用。很多开发者都在这基础上进行改造开发。注意`react-scripts`就是create-react-app脚手架的核心配置代码。\\n\\n目前如果要自己定制配置，有两种方案可选。一个是`eject`，他的原理是将`react-scripts`拆除然后将配置暴露到应用顶层，用户就可以自行进行配置。另一个是使用`react-app-rewired`，用户通过`config-overrides.js`增加修改配置。两者各有好处。`eject`直接暴露可以自行配置，但是坏处就是`react-scripts`被解散了，就不能随官方配置进行升级。`react-scripts`包揽了那些最基础配置的脏活累活，并且一直再维护，比如修复BUG和打包优化，运行速度优化。前端发展的迅速，这些基础配置随着基础设施的升级，可能随时都会变化。我觉得`eject`后要就需要承担维护成本的风险。我的理念是将专业的事情交给专业的人去做就好了，我们应该享受金字塔底层带来的基础设施便利去创造价值，没必要重复造轮子，更没必要在轮子上耗费过多的维护成本。\\n\\n我的理念是推荐使用`config-overrides.js`来定制配置，降低维护成本。也就是在`react-scripts`的配置上进行增删改查，不影响底层配置代码，在未来需要的时候还可以进行无缝升级`react-scripts`，来提升速度或者解决你未关注到的BUG等等。但是`create-react-app`只是提供最最基础的设施建设，我们最常用的框架配置都需要自己去定制，每次创建项目的时候都需要再写一次定制代码，相当烦人。所以才有了今天的主题基于create-react-app的脚手架，确切说应该是基于`react-scripts`的脚手架。\\n\\n所以这篇文章主题应该有两个\\n\\n- 怎么制作CLI工具\\n- 怎么根据`react-scripts`来写脚手架\\n\\n项目核心代码在github上：(https://github.com/LinYouYuan/react-cli)，这个链接上面也有使用帮助说明，可以先点击进去看，可以更好的理解使用和需求。\\n\\n## 项目核心需求\\n\\n我们需求是：\\n\\n1. 保证基础依赖和官方同步；\\n2. 创建时增加常用框架选择;\\n3. 创建项目后配置项可定制;\\n\\n第一点，我们需要引入`react-scripts`和`react-app-rewired`，来保持官方同步和可定制型。\\n\\n第二点，我整理出我们常用的框架可选项：\\n\\n类型 | 可选框架名称\\n:- | :- \\n语言 | JavaScript / TypeScript\\n状态管理库 | Redux / Mobx\\ncss预处理器 | SCSS / LESS / styled-components\\nUI组件 | Antd / Ant-mobile\\n代码规范 | Airbnb\\nHTTP库 | Axios\\n路由 | react-router\\n\\n第三点，创项目后我们可以通过`config-overrides.js`文件来预先配置，然后用户可以再此文件进行继续配置和改造。\\n\\n## 制作CLI工具\\n\\n### 引入常用工具包\\n\\n首先创建nodejs项目。制作常用的Cli工具，我们一般都需要安装下面5个工具包：（执行`npm install`或者其他工具安装）\\n\\n- commander: 用来接收输入命令参数，然后处理事件；\\n- execa: 用来执行操作命令，一个更好的`child_process`；\\n- inquirer: 这是创建cli最主要的工具，可以生成非常美观的命令行界面；\\n- chalk: 可以修改字体颜色；\\n- fs-extra: 比原生fs更好用的fs；\\n\\n### 创建全局使用\\n\\n我们首先要创建一个像`creact-react-app`一样直接在全局就可以执行使用的命令。\\n\\n1. 我们在根目录下创建文件夹和文件`lib/index.js`，这个其实就是入口执行文件。其中`#!/usr/bin/env node`一定要填写。\\n\\n`lib/index.js`\\n\\n```js\\n#!/usr/bin/env node\\nconsole.log('hello world')\\n```\\n\\n2. 然后在`package.json`中添加代码，如下，其中`react-cli`就是全局要使用的命令名称，`lib/index.js`就是上面要执行的文件地址。\\n\\n`package.json`\\n\\n```json\\n\\\"bin\\\": {\\n    \\\"react-cli\\\": \\\"lib/index.js\\\"\\n}\\n```\\n\\n3. 执行`npm link`。执行完成后，我们就可以把命令挂载到全局，效果和`npm install -g`后一样，可以全局输入命令。link的主要目的是给我开发调试用的。现在可以直接在控制台输入`react-cli`执行，你就可以看到打印的`hello world`了。\\n\\n4. 等开发完成，你可以试试发布到npm包上，但是我推荐等开发完成后再发布，当然不妨碍你好奇心想试试。发布前需要执行`npm login`，登录npm账号密码，注意你如果是淘宝源你需要通过`npm config set registry http://registry.npm.tongdun.cn`暂时切回官方源。然后执行`npm publish`发布，这个时候也要注意，你的`package.json`中的`name`也就是项目名称不要和别人重名了。发布好你就可以通过`npm i <you project name> -g`来全局安装你的包。\\n\\n## 命令管理\\n\\n在`lib/index.js`中，我们输入如下\\n\\n```js\\nconst program = require('commander');\\nconst chalk = require(\\\"chalk\\\");\\n\\nprogram\\n  .version(require('../package').version)\\n  .usage('<command> [options]');\\n\\nprogram\\n  .command('create <app-name>')\\n  .description('create a new project powered by react-cli')\\n  .action(name => {\\n    // 这里处理逻辑\\n    console.log(chalk.blue(`React CLI v${require('../package').version}`));\\n    // const create = require('./cli/create');\\n    // create(name);\\n  });\\n```\\n\\n这里主要通过`commander`来配置接受不同命令处理。这里主要就是要接受`create <app-name>`参数，然后处理输入命令后的逻辑。其中`chalk`就是颜色处理。\\n\\n然后继续处理未输入和输入错时候弹出帮助如下\\n\\n```js\\nprogram\\n  .arguments('<command>')\\n  .action((cmd) => {\\n    program.outputHelp()\\n    console.log(`  ` + chalk.red(`Unknown command ${chalk.yellow(cmd)}.`))\\n    console.log()\\n  })\\n\\nprogram.parse(process.argv);\\n\\nif (!program.args.length) {\\n  program.outputHelp();\\n}\\n```\\n\\n## 交互界面\\n\\n接收到用户输入的命令后，我们就要呈现交互界面，这个时候我们就用到了非常好用的工具`inquirer`。具体可以实现多少种交互形式可以点[inquirer的npm网站](https://www.npmjs.com/package/inquirer)的介绍看。我这里主要用了`list`和`confirm`的功能，也就是列表选择和寻问功能。比如让用户选择使用什么框架：\\n\\n```js\\nfunction selectManually(appName) {\\n  inquirer\\n    .prompt([\\n      {\\n        type: 'list',\\n        name: 'language',\\n        message: 'pick a language:',\\n        choices: [\\n          'JavaScript',\\n          'TypeScript',\\n        ]\\n      },\\n      {\\n        type: 'list',\\n        name: 'stateManagement',\\n        message: 'Pick a state management:',\\n        choices: [\\n          'Mobx',\\n          'Redux',\\n        ]\\n      },\\n      {\\n        type: 'list',\\n        name: 'cssPre',\\n        message: 'Pick a CSS pre-processor:',\\n        choices: [\\n          'LESS',\\n          'SCSS/SASS',\\n          'styled-components',\\n        ]\\n      },\\n      {\\n        type: 'list',\\n        name: 'design',\\n        message: 'Pick a UI Design:',\\n        choices: [\\n          'Ant Design',\\n          'Ant Design Mobile',\\n        ]\\n      },\\n    ])\\n    .then(answers => {\\n      const creator = new Creator(appName, answers);\\n      creator.create();\\n    })\\n}\\n```\\n## 创建项目\\n\\n新建一个Creator类，主要用来创建项目用的，初始化接受两个参数，一个是项目名称，一个是用户选择的框架。我项目中的模板存放在`lib/packages/common-default`中。这里我主要针对各种不同的配置，来修改`packages.json`、`babelrc`、`config-overrides.js`文件的内容就好了，然后执行复制操作。\\n\\n```js\\nconst chalk = require(\\\"chalk\\\");\\n\\nconst fs = require(\\\"fs-extra\\\");\\n\\nconst path = require(\\\"path\\\");\\n\\nconst inquirer = module.require('inquirer');\\n\\nconst {\\n  getPackageJson,\\n  writeJsonToApp,\\n  copyFiles,\\n  setNewPackageVersion,\\n  installPackge,\\n  setUserConfig,\\n} = require('../packages/common');\\n\\nclass Creator {\\n  constructor(appName, answers) {\\n    this.appName = appName;\\n    this.answers = answers;\\n    this.appDir = path.resolve(process.cwd(), this.appName);\\n    this.package = getPackageJson('cli-switch');\\n    this.babelrc = {\\n      plugins: [\\n        [\\n          \\\"import\\\",\\n          {\\n            libraryName: \\\"antd\\\",\\n            style: true,\\n          }\\n        ]\\n      ]\\n    }\\n  }\\n\\n  async testExistDir() {\\n    if (fs.existsSync(this.appDir)) {\\n      const { override } = await inquirer.prompt([\\n        {\\n          type: \\\"confirm\\\",\\n          name: \\\"override\\\",\\n          message: chalk.red(`directory ${this.appName} exist,override it?`)\\n        }\\n      ]);\\n      if (override) {\\n        console.log(chalk.green(\\\"removing...\\\"));\\n        fs.removeSync(this.appDir);\\n        return true;\\n      } else {\\n        process.exit(1);\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  async create() {\\n    const { stateManagement, cssPre, design } = this.answers;\\n\\n    console.log();\\n\\n    console.log(`you pick: ${chalk.yellow(`${stateManagement}, ${cssPre}, ${design}, Router, ESLint`)}`);\\n\\n    console.log();\\n\\n    const isOk = await this.testExistDir(this.appDir, this.appName);\\n\\n    if (!isOk) {\\n      return;\\n    }\\n\\n    console.log(`🚀  Invoking generators...`);\\n\\n    console.log();\\n\\n    let { dependencies, devDependencies } = this.package;\\n\\n    switch (stateManagement) {\\n      case 'Mobx':\\n        dependencies['mobx'] = '';\\n        dependencies['mobx-react'] = '';\\n        break;\\n      case 'Redux':\\n        devDependencies['redux-devtools'] = '';\\n        dependencies['redux'] = '';\\n        dependencies['react-redux'] = '';\\n        break;\\n    }\\n\\n    switch (design) {\\n      case 'Ant Design':\\n        let myTd = this.babelrc.plugins[0][1];\\n        myTd.libraryDirectory = 'es';\\n        dependencies['antd'] = '';\\n        break;\\n      case 'Ant Design Mobile':\\n        let myTdw = this.babelrc.plugins[0][1];\\n        myTdw.libraryName = 'antd-mobile';\\n        myTdw.style = 'css';\\n        dependencies['antd-mobile'] = '';\\n        break;\\n    }\\n\\n    switch (cssPre) {\\n      case 'LESS':\\n        dependencies['less-loader'] = '';\\n        devDependencies['react-app-rewire-less-modules'] = '';\\n        break;\\n      case 'SCSS/SASS':\\n        dependencies['node-sass'] = '';\\n        break;\\n      case 'styled-components':\\n        dependencies['styled-components'] = '';\\n        devDependencies['babel-plugin-styled-components'] = '';\\n        this.babelrc.plugins.push(\\\"babel-plugin-styled-components\\\");\\n        break;\\n    }\\n\\n    fs.mkdirSync(this.appDir);\\n\\n    this.beginCopy(cssPre === 'LESS');\\n\\n    writeJsonToApp(this.appDir, '.babelrc', this.babelrc);\\n\\n    console.log(`📦  Installing additional dependencies...`);\\n\\n    installPackge(this.appDir);\\n\\n    setUserConfig({ hasConfig: true, config: this.answers });\\n\\n    console.log(`🎉  Successfully created project ${chalk.yellow(this.appName)}.`)\\n\\n    process.exit(1);\\n  }\\n\\n  async beginCopy(isLess = false) {\\n    setNewPackageVersion(this.package.dependencies);\\n    setNewPackageVersion(this.package.devDependencies);\\n\\n    this.package.name = this.appName;\\n\\n    copyFiles(path.join(__filename, '../../packages/common-default'), this.appDir);\\n\\n    writeJsonToApp(this.appDir, 'package.json', this.package);\\n\\n    if (!isLess) {\\n      fs.copySync(path.join(__filename, '../../packages/cli-switch/config-overrides.js'), this.appDir + '/config-overrides.js');\\n    }\\n\\n  }\\n}\\n\\nmodule.exports = Creator;\\n```\\n\\n## 创建好项目后配置\\n\\n创建好项目只要在`config-overrides.js`里配置Webpack devServer jest。可以在这里添加自定义的config配置来增加修改loader, plugin, optimization进行配置。`webpackMerge`使用混入的方式去添加config。\\n\\n`config-overrides.js`\\n\\n```js\\nconst path = require('path');\\nconst webpackMerge = require('@/webpack-merge');\\n\\nconst appSrc = path.join(__dirname, 'src');\\n\\nSKIP_PREFLIGHT_CHECK = true\\n\\nconst {\\n  override, addLessLoader, addWebpackAlias, useBabelRc, addDecoratorsLegacy,\\n} = require('@/customize-cra');\\n\\n//打包分析\\nconst BundleAnalyzerPlugin = require('@/webpack-bundle-analyzer').BundleAnalyzerPlugin;\\n\\n// 这里可以直接修改 Host 或者 Port\\n// process.env.HOST = 'localhost.xxxx.com';\\n// process.env.PORT = 3006;\\n\\n// 生产环境是否打包 Source Map\\nprocess.env.GENERATE_SOURCEMAP = false;\\n\\nmodule.exports = {\\n  // 配置devServer\\n  devServer: configFunction => (proxy, allowedHost) => {\\n    proxy = {\\n      '/mock': {\\n        // 这里配置代理服务地址\\n        target: 'http://localhost:3000',\\n        changeOrigin: true,\\n        pathRewrite: { '^/mock': '' },\\n      },\\n    }\\n    // allowedHost： 添加额外的地址\\n    const config = configFunction(proxy, allowedHost);\\n    return config;\\n  },\\n\\n  // 配置webpack \\n  webpack: (config, env) => {\\n    // 开发环境\\n    const isEnvDevelopment = env === 'development';\\n    // 生产环境\\n    const isEnvProduction = env === 'production';\\n\\n    // 通过customize-cra插件覆盖\\n    config = override(\\n      // 配置路径别名\\n      addWebpackAlias({ '@': appSrc }),\\n      // 对Decorators支持\\n      addDecoratorsLegacy(),\\n      useBabelRc(),\\n    )(config, env);\\n\\n    return webpackMerge(config, {\\n      // 用户可以在这里添加自定义的config配置 来增加修改loader, plugin, optimization\\n      plugins: [\\n        // new BundleAnalyzerPlugin(),\\n      ],\\n      optimization: {\\n        splitChunks: {\\n          cacheGroups: {\\n            vendors: { // 基本框架\\n              chunks: 'all',\\n              test: /(react|react-dom|react-dom-router|babel-polyfill|mobx|antd)/,\\n              priority: 100,\\n              name: 'vendors',\\n            },\\n            asyncCommons: { // 其余异步加载包\\n              chunks: 'async',\\n              minChunks: 2,\\n              name: 'async-commons',\\n              priority: 90,\\n            },\\n            commons: { // 其余同步加载包\\n              chunks: 'all',\\n              minChunks: 2,\\n              name: 'commons',\\n              priority: 80,\\n            },\\n            // echartsVendor: { // 异步加载echarts包\\n            //   test: /echarts/,\\n            //   priority: 100, // 高于async-commons优先级\\n            //   name: 'echartsVendor',\\n            //   chunks: 'async'\\n            // },\\n          }\\n        },\\n      }\\n    })\\n  },\\n\\n  // 配置测试\\n  jest: config => {\\n    config.moduleNameMapper = {\\n      // 同webpack一样配置别名\\n      '@/(.*)$': '<rootDir>/src/$1',\\n    }\\n    return config;\\n  },\\n}\\n```\\n\\n## 使用简单演示\\n\\n用户第一次创建有两个选项\\n\\n- `default (JavaScript, Redux, Antd, Less, Router, ESLint)` 默认配置\\n- `Manually select features ` 选择配置\\n\\n第二次创建的时候会多一个用户上次选择过的选项配置`config`，就像如下进行选择配置。\\n\\n![演示1](脚手架工具/jiao_00.jpg)\\n\\n![演示2](脚手架工具/jiao_01.jpg)\\n\\n![演示3](脚手架工具/jiao_02.jpg)\\n\"}"],"sourceRoot":""}